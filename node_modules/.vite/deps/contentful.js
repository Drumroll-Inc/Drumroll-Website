import {
  axios_default
} from "./chunk-4GUPNKL2.js";
import {
  __commonJS,
  __toESM
} from "./chunk-DC5AMYBS.js";

// node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "node_modules/es-errors/index.js"(exports, module) {
    "use strict";
    module.exports = Error;
  }
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "node_modules/es-errors/eval.js"(exports, module) {
    "use strict";
    module.exports = EvalError;
  }
});

// node_modules/es-errors/range.js
var require_range = __commonJS({
  "node_modules/es-errors/range.js"(exports, module) {
    "use strict";
    module.exports = RangeError;
  }
});

// node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "node_modules/es-errors/ref.js"(exports, module) {
    "use strict";
    module.exports = ReferenceError;
  }
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "node_modules/es-errors/syntax.js"(exports, module) {
    "use strict";
    module.exports = SyntaxError;
  }
});

// node_modules/es-errors/type.js
var require_type = __commonJS({
  "node_modules/es-errors/type.js"(exports, module) {
    "use strict";
    module.exports = TypeError;
  }
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "node_modules/es-errors/uri.js"(exports, module) {
    "use strict";
    module.exports = URIError;
  }
});

// node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  "node_modules/gopd/gOPD.js"(exports, module) {
    "use strict";
    module.exports = Object.getOwnPropertyDescriptor;
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports, module) {
    "use strict";
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "node_modules/es-define-property/index.js"(exports, module) {
    "use strict";
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module.exports = $defineProperty;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports, module) {
    "use strict";
    module.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _2 in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports, module) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a2, b2) {
      var arr = [];
      for (var i = 0; i < a2.length; i += 1) {
        arr[i] = a2[i];
      }
      for (var j2 = 0; j2 < b2.length; j2 += 1) {
        arr[j2 + a2.length] = b2[j2];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j2 = 0; i < arrLike.length; i += 1, j2 += 1) {
        arr[j2] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({
  "node_modules/call-bind-apply-helpers/functionCall.js"(exports, module) {
    "use strict";
    module.exports = Function.prototype.call;
  }
});

// node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({
  "node_modules/call-bind-apply-helpers/functionApply.js"(exports, module) {
    "use strict";
    module.exports = Function.prototype.apply;
  }
});

// node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({
  "node_modules/call-bind-apply-helpers/reflectApply.js"(exports, module) {
    "use strict";
    module.exports = typeof Reflect === "function" && Reflect.apply;
  }
});

// node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({
  "node_modules/call-bind-apply-helpers/actualApply.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module.exports = $reflectApply || bind.call($call, $apply);
  }
});

// node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({
  "node_modules/call-bind-apply-helpers/index.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    var $TypeError = require_type();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module.exports = function callBindBasic(args) {
      if (args.length < 1 || typeof args[0] !== "function") {
        throw new $TypeError("a function is required");
      }
      return $actualApply(bind, $call, args);
    };
  }
});

// node_modules/dunder-proto/get.js
var require_get = __commonJS({
  "node_modules/dunder-proto/get.js"(exports, module) {
    "use strict";
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor = (
      /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype
    );
    var desc = hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
      /** @type {import('./get')} */
      function getDunder(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
      }
    ) : false;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports, module) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module.exports = bind.call(call, $hasOwn);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports, module) {
    "use strict";
    var undefined2;
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getDunderProto = require_get();
    var getProto = typeof Reflect === "function" && Reflect.getPrototypeOf || Object.getPrototypeOf || getDunderProto;
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call($call, Array.prototype.concat);
    var $spliceApply = bind.call($apply, Array.prototype.splice);
    var $replace = bind.call($call, String.prototype.replace);
    var $strSlice = bind.call($call, String.prototype.slice);
    var $exec = bind.call($call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/define-data-property/index.js
var require_define_data_property = __commonJS({
  "node_modules/define-data-property/index.js"(exports, module) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var gopd = require_gopd();
    module.exports = function defineDataProperty(obj, property, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property !== "string" && typeof property !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj, property);
      if ($defineProperty) {
        $defineProperty(obj, property, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
  }
});

// node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "node_modules/has-property-descriptors/index.js"(exports, module) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      return !!$defineProperty;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!$defineProperty) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e) {
        return true;
      }
    };
    module.exports = hasPropertyDescriptors;
  }
});

// node_modules/set-function-length/index.js
var require_set_function_length = __commonJS({
  "node_modules/set-function-length/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var define = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var gOPD = require_gopd();
    var $TypeError = require_type();
    var $floor = GetIntrinsic("%Math.floor%");
    module.exports = function setFunctionLength(fn, length) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
        throw new $TypeError("`length` must be a positive 32-bit integer");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      var functionLengthIsConfigurable = true;
      var functionLengthIsWritable = true;
      if ("length" in fn && gOPD) {
        var desc = gOPD(fn, "length");
        if (desc && !desc.configurable) {
          functionLengthIsConfigurable = false;
        }
        if (desc && !desc.writable) {
          functionLengthIsWritable = false;
        }
      }
      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
          define(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length,
            true,
            true
          );
        } else {
          define(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length
          );
        }
      }
      return fn;
    };
  }
});

// node_modules/call-bind-apply-helpers/applyBind.js
var require_applyBind = __commonJS({
  "node_modules/call-bind-apply-helpers/applyBind.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var actualApply = require_actualApply();
    module.exports = function applyBind() {
      return actualApply(bind, $apply, arguments);
    };
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports, module) {
    "use strict";
    var setFunctionLength = require_set_function_length();
    var $defineProperty = require_es_define_property();
    var callBindBasic = require_call_bind_apply_helpers();
    var applyBind = require_applyBind();
    module.exports = function callBind(originalFunction) {
      var func = callBindBasic(arguments);
      var adjustedLength = originalFunction.length - (arguments.length - 1);
      return setFunctionLength(
        func,
        1 + (adjustedLength > 0 ? adjustedLength : 0),
        true
      );
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  }
});

// node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "node_modules/call-bind/callBound.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// (disabled):node_modules/object-inspect/util.inspect
var require_util = __commonJS({
  "(disabled):node_modules/object-inspect/util.inspect"() {
  }
});

// node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "node_modules/object-inspect/index.js"(exports, module) {
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O2) {
      return O2.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    var quotes = {
      __proto__: null,
      "double": '"',
      single: "'"
    };
    var quoteREs = {
      __proto__: null,
      "double": /(["\\])/g,
      single: /(['\\])/g
    };
    module.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && !has(quotes, opts.quoteStyle)) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray3(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
          s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
        }
        s += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s += "...";
        }
        s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s;
      }
      if (isArray3(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString2(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (typeof window !== "undefined" && obj === window) {
        return "{ [object Window] }";
      }
      if (typeof globalThis !== "undefined" && obj === globalThis || typeof global !== "undefined" && obj === global) {
        return "{ [object globalThis] }";
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject2 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s, defaultStyle, opts) {
      var style = opts.quoteStyle || defaultStyle;
      var quoteChar = quotes[style];
      return quoteChar + s + quoteChar;
    }
    function quote(s) {
      return $replace.call(String(s), /"/g, "&quot;");
    }
    function isArray3(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString2(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has(obj, key) {
      return hasOwn.call(obj, key);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f) {
      if (f.name) {
        return f.name;
      }
      var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
      if (m) {
        return m[1];
      }
      return null;
    }
    function indexOf(xs, x2) {
      if (xs.indexOf) {
        return xs.indexOf(x2);
      }
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x2) {
          return i;
        }
      }
      return -1;
    }
    function isMap(x2) {
      if (!mapSize || !x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        mapSize.call(x2);
        try {
          setSize.call(x2);
        } catch (s) {
          return true;
        }
        return x2 instanceof Map;
      } catch (e) {
      }
      return false;
    }
    function isWeakMap(x2) {
      if (!weakMapHas || !x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x2, weakMapHas);
        try {
          weakSetHas.call(x2, weakSetHas);
        } catch (s) {
          return true;
        }
        return x2 instanceof WeakMap;
      } catch (e) {
      }
      return false;
    }
    function isWeakRef(x2) {
      if (!weakRefDeref || !x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x2);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isSet(x2) {
      if (!setSize || !x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        setSize.call(x2);
        try {
          mapSize.call(x2);
        } catch (m) {
          return true;
        }
        return x2 instanceof Set;
      } catch (e) {
      }
      return false;
    }
    function isWeakSet(x2) {
      if (!weakSetHas || !x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x2, weakSetHas);
        try {
          weakMapHas.call(x2, weakMapHas);
        } catch (s) {
          return true;
        }
        return x2 instanceof WeakSet;
      } catch (e) {
      }
      return false;
    }
    function isElement(x2) {
      if (!x2 || typeof x2 !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x2 instanceof HTMLElement) {
        return true;
      }
      return typeof x2.nodeName === "string" && typeof x2.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var quoteRE = quoteREs[opts.quoteStyle || "single"];
      quoteRE.lastIndex = 0;
      var s = $replace.call($replace.call(str, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s, "single", opts);
    }
    function lowbyte(c) {
      var n = c.charCodeAt(0);
      var x2 = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n];
      if (x2) {
        return "\\" + x2;
      }
      return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect) {
      var isArr = isArray3(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
          xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k2 = 0; k2 < syms.length; k2++) {
          symMap["$" + syms[k2]] = syms[k2];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j2 = 0; j2 < syms.length; j2++) {
          if (isEnumerable.call(obj, syms[j2])) {
            xs.push("[" + inspect(syms[j2]) + "]: " + inspect(obj[syms[j2]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "node_modules/side-channel/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var inspect = require_object_inspect();
    var $TypeError = require_type();
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $Map = GetIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var listGetNode = function(list, key) {
      var prev = list;
      var curr;
      for (; (curr = prev.next) !== null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          curr.next = /** @type {NonNullable<typeof list.next>} */
          list.next;
          list.next = curr;
          return curr;
        }
      }
    };
    var listGet = function(objects, key) {
      var node = listGetNode(objects, key);
      return node && node.value;
    };
    var listSet = function(objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = /** @type {import('.').ListNode<typeof value>} */
        {
          // eslint-disable-line no-param-reassign, no-extra-parens
          key,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key) {
      return !!listGetNode(objects, key);
    };
    module.exports = function getSideChannel() {
      var $wm;
      var $m;
      var $o;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        get: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapGet($m, key);
            }
          } else {
            if ($o) {
              return listGet($o, key);
            }
          }
        },
        has: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapHas($m, key);
            }
          } else {
            if ($o) {
              return listHas($o, key);
            }
          }
          return false;
        },
        set: function(key, value) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if ($Map) {
            if (!$m) {
              $m = new $Map();
            }
            $mapSet($m, key, value);
          } else {
            if (!$o) {
              $o = { key: {}, next: null };
            }
            listSet($o, key, value);
          }
        }
      };
      return channel;
    };
  }
});

// node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "node_modules/qs/lib/formats.js"(exports, module) {
    "use strict";
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: function(value) {
          return replace.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
          return String(value);
        }
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// node_modules/qs/lib/utils.js
var require_utils = __commonJS({
  "node_modules/qs/lib/utils.js"(exports, module) {
    "use strict";
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var isArray3 = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i = 0; i < 256; ++i) {
        array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = function compactQueue2(queue) {
      while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray3(obj)) {
          var compacted = [];
          for (var j2 = 0; j2 < obj.length; ++j2) {
            if (typeof obj[j2] !== "undefined") {
              compacted.push(obj[j2]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject = function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? { __proto__: null } : {};
      for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== "undefined") {
          obj[i] = source[i];
        }
      }
      return obj;
    };
    var merge = function merge2(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object" && typeof source !== "function") {
        if (isArray3(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray3(target) && !isArray3(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray3(target) && isArray3(source)) {
        source.forEach(function(item, i) {
          if (has.call(target, i)) {
            var targetItem = target[i];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i] = merge2(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
          acc[key] = merge2(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    };
    var assign2 = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    };
    var decode = function(str, defaultDecoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e) {
        return strWithoutPlus;
      }
    };
    var limit = 1024;
    var encode = function encode2(str, defaultEncoder, charset, kind, format) {
      if (str.length === 0) {
        return str;
      }
      var string = str;
      if (typeof str === "symbol") {
        string = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var j2 = 0; j2 < string.length; j2 += limit) {
        var segment = string.length >= limit ? string.slice(j2, j2 + limit) : string;
        var arr = [];
        for (var i = 0; i < segment.length; ++i) {
          var c = segment.charCodeAt(i);
          if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats.RFC1738 && (c === 40 || c === 41)) {
            arr[arr.length] = segment.charAt(i);
            continue;
          }
          if (c < 128) {
            arr[arr.length] = hexTable[c];
            continue;
          }
          if (c < 2048) {
            arr[arr.length] = hexTable[192 | c >> 6] + hexTable[128 | c & 63];
            continue;
          }
          if (c < 55296 || c >= 57344) {
            arr[arr.length] = hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
            continue;
          }
          i += 1;
          c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
          arr[arr.length] = hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
        }
        out += arr.join("");
      }
      return out;
    };
    var compact = function compact2(value) {
      var queue = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for (var j2 = 0; j2 < keys.length; ++j2) {
          var key = keys[j2];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      compactQueue(queue);
      return value;
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer = function isBuffer2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    var combine = function combine2(a2, b2) {
      return [].concat(a2, b2);
    };
    var maybeMap = function maybeMap2(val, fn) {
      if (isArray3(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
          mapped.push(fn(val[i]));
        }
        return mapped;
      }
      return fn(val);
    };
    module.exports = {
      arrayToObject,
      assign: assign2,
      combine,
      compact,
      decode,
      encode,
      isBuffer,
      isRegExp,
      maybeMap,
      merge
    };
  }
});

// node_modules/qs/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/qs/lib/stringify.js"(exports, module) {
    "use strict";
    var getSideChannel = require_side_channel();
    var utils = require_utils();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      comma: "comma",
      indices: function indices(prefix, key) {
        return prefix + "[" + key + "]";
      },
      repeat: function repeat(prefix) {
        return prefix;
      }
    };
    var isArray3 = Array.isArray;
    var push = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push.apply(arr, isArray3(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      allowEmptyArrays: false,
      arrayFormat: "indices",
      charset: "utf-8",
      charsetSentinel: false,
      commaRoundTrip: false,
      delimiter: "&",
      encode: true,
      encodeDotInKeys: false,
      encoder: utils.encode,
      encodeValuesOnly: false,
      filter: void 0,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      // deprecated
      indices: false,
      serializeDate: function serializeDate(date) {
        return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
      return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
    };
    var sentinel = {};
    var stringify = function stringify2(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter === "function") {
        obj = filter(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray3(obj)) {
        obj = utils.maybeMap(obj, function(value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format) : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray3(obj)) {
        if (encodeValuesOnly && encoder) {
          obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray3(filter)) {
        objKeys = filter;
      } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
      }
      var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
      var adjustedPrefix = commaRoundTrip && isArray3(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
      if (allowEmptyArrays && isArray3(obj) && obj.length === 0) {
        return adjustedPrefix + "[]";
      }
      for (var j2 = 0; j2 < objKeys.length; ++j2) {
        var key = objKeys[j2];
        var value = typeof key === "object" && key && typeof key.value !== "undefined" ? key.value : obj[key];
        if (skipNulls && value === null) {
          continue;
        }
        var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\./g, "%2E") : String(key);
        var keyPrefix = isArray3(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify2(
          value,
          keyPrefix,
          generateArrayPrefix,
          commaRoundTrip,
          allowEmptyArrays,
          strictNullHandling,
          skipNulls,
          encodeDotInKeys,
          generateArrayPrefix === "comma" && encodeValuesOnly && isArray3(obj) ? null : encoder,
          filter,
          sort,
          allowDots,
          serializeDate,
          format,
          formatter,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
        throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format = opts.format;
      }
      var formatter = formats.formatters[format];
      var filter = defaults.filter;
      if (typeof opts.filter === "function" || isArray3(opts.filter)) {
        filter = opts.filter;
      }
      var arrayFormat;
      if (opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if ("indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = defaults.arrayFormat;
      }
      if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        arrayFormat,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        commaRoundTrip: !!opts.commaRoundTrip,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter,
        format,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module.exports = function(object, opts) {
      var obj = object;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter;
      if (typeof options.filter === "function") {
        filter = options.filter;
        obj = filter("", obj);
      } else if (isArray3(options.filter)) {
        filter = options.filter;
        objKeys = filter;
      }
      var keys = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
      var commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel = getSideChannel();
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        var value = obj[key];
        if (options.skipNulls && value === null) {
          continue;
        }
        pushToArray(keys, stringify(
          value,
          key,
          generateArrayPrefix,
          commaRoundTrip,
          options.allowEmptyArrays,
          options.strictNullHandling,
          options.skipNulls,
          options.encodeDotInKeys,
          options.encode ? options.encoder : null,
          options.filter,
          options.sort,
          options.allowDots,
          options.serializeDate,
          options.format,
          options.formatter,
          options.encodeValuesOnly,
          options.charset,
          sideChannel
        ));
      }
      var joined = keys.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// node_modules/qs/lib/parse.js
var require_parse = __commonJS({
  "node_modules/qs/lib/parse.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var has = Object.prototype.hasOwnProperty;
    var isArray3 = Array.isArray;
    var defaults = {
      allowDots: false,
      allowEmptyArrays: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decodeDotInKeys: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      duplicates: "combine",
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictDepth: false,
      strictNullHandling: false
    };
    var interpretNumericEntities = function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var parseArrayValue = function(val, options) {
      if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      return val;
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str, options) {
      var obj = { __proto__: null };
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      cleanStr = cleanStr.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(options.delimiter, limit);
      var skipIndex = -1;
      var i;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
          if (parts[i].indexOf("utf8=") === 0) {
            if (parts[i] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i;
            i = parts.length;
          }
        }
      }
      for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
          continue;
        }
        var part = parts[i];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key;
        var val;
        if (pos === -1) {
          key = options.decoder(part, defaults.decoder, charset, "key");
          val = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
          val = utils.maybeMap(
            parseArrayValue(part.slice(pos + 1), options),
            function(encodedVal) {
              return options.decoder(encodedVal, defaults.decoder, charset, "value");
            }
          );
        }
        if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(String(val));
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray3(val) ? [val] : val;
        }
        var existing = has.call(obj, key);
        if (existing && options.duplicates === "combine") {
          obj[key] = utils.combine(obj[key], val);
        } else if (!existing || options.duplicates === "last") {
          obj[key] = val;
        }
      }
      return obj;
    };
    var parseObject = function(chain, val, options, valuesParsed) {
      var leaf = valuesParsed ? val : parseArrayValue(val, options);
      for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];
        if (root === "[]" && options.parseArrays) {
          obj = options.allowEmptyArrays && (leaf === "" || options.strictNullHandling && leaf === null) ? [] : [].concat(leaf);
        } else {
          obj = options.plainObjects ? { __proto__: null } : {};
          var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
          var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
          var index2 = parseInt(decodedRoot, 10);
          if (!options.parseArrays && decodedRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index2) && root !== decodedRoot && String(index2) === decodedRoot && index2 >= 0 && (options.parseArrays && index2 <= options.arrayLimit)) {
            obj = [];
            obj[index2] = leaf;
          } else if (decodedRoot !== "__proto__") {
            obj[decodedRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(parent);
      }
      var i = 0;
      while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(segment[1]);
      }
      if (segment) {
        if (options.strictDepth === true) {
          throw new RangeError("Input depth exceeded depth option of " + options.depth + " and strictDepth is true");
        }
        keys.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys, val, options, valuesParsed);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") {
        throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      var duplicates = typeof opts.duplicates === "undefined" ? defaults.duplicates : opts.duplicates;
      if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") {
        throw new TypeError("The duplicates option must be either combine, first, or last");
      }
      var allowDots = typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
      return {
        allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
        duplicates,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictDepth: typeof opts.strictDepth === "boolean" ? !!opts.strictDepth : defaults.strictDepth,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module.exports = function(str, opts) {
      var options = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? { __proto__: null } : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? { __proto__: null } : {};
      var keys = Object.keys(tempObj);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
        obj = utils.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// node_modules/qs/lib/index.js
var require_lib = __commonJS({
  "node_modules/qs/lib/index.js"(exports, module) {
    "use strict";
    var stringify = require_stringify();
    var parse = require_parse();
    var formats = require_formats();
    module.exports = {
      formats,
      parse,
      stringify
    };
  }
});

// node_modules/process/browser.js
var require_browser = __commonJS({
  "node_modules/process/browser.js"(exports, module) {
    var process3 = module.exports = {};
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
      throw new Error("setTimeout has not been defined");
    }
    function defaultClearTimeout() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        if (typeof setTimeout === "function") {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === "function") {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
      }
    })();
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout(fun, 0);
      } catch (e) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e2) {
          return cachedSetTimeout.call(this, fun, 0);
        }
      }
    }
    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
      }
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        return cachedClearTimeout(marker);
      } catch (e) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e2) {
          return cachedClearTimeout.call(this, marker);
        }
      }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }
      draining = false;
      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }
      if (queue.length) {
        drainQueue();
      }
    }
    function drainQueue() {
      if (draining) {
        return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
      var len = queue.length;
      while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }
        queueIndex = -1;
        len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }
    process3.nextTick = function(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    };
    function Item(fun, array) {
      this.fun = fun;
      this.array = array;
    }
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    process3.title = "browser";
    process3.browser = true;
    process3.env = {};
    process3.argv = [];
    process3.version = "";
    process3.versions = {};
    function noop2() {
    }
    process3.on = noop2;
    process3.addListener = noop2;
    process3.once = noop2;
    process3.off = noop2;
    process3.removeListener = noop2;
    process3.removeAllListeners = noop2;
    process3.emit = noop2;
    process3.prependListener = noop2;
    process3.prependOnceListener = noop2;
    process3.listeners = function(name) {
      return [];
    };
    process3.binding = function(name) {
      throw new Error("process.binding is not supported");
    };
    process3.cwd = function() {
      return "/";
    };
    process3.chdir = function(dir) {
      throw new Error("process.chdir is not supported");
    };
    process3.umask = function() {
      return 0;
    };
  }
});

// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/lodash/_freeGlobal.js"(exports, module) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module.exports = freeGlobal;
  }
});

// node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/lodash/_root.js"(exports, module) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module.exports = root;
  }
});

// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/lodash/_Symbol.js"(exports, module) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module.exports = Symbol2;
  }
});

// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/lodash/_getRawTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty3.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module.exports = getRawTag;
  }
});

// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/lodash/_objectToString.js"(exports, module) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module.exports = objectToString;
  }
});

// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/lodash/_baseGetTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module.exports = baseGetTag;
  }
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "node_modules/lodash/isArray.js"(exports, module) {
    var isArray3 = Array.isArray;
    module.exports = isArray3;
  }
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/lodash/isObjectLike.js"(exports, module) {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module.exports = isObjectLike;
  }
});

// node_modules/lodash/isString.js
var require_isString = __commonJS({
  "node_modules/lodash/isString.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isArray3 = require_isArray();
    var isObjectLike = require_isObjectLike();
    var stringTag = "[object String]";
    function isString2(value) {
      return typeof value == "string" || !isArray3(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
    }
    module.exports = isString2;
  }
});

// node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "node_modules/lodash/_overArg.js"(exports, module) {
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    module.exports = overArg;
  }
});

// node_modules/lodash/_getPrototype.js
var require_getPrototype = __commonJS({
  "node_modules/lodash/_getPrototype.js"(exports, module) {
    var overArg = require_overArg();
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    module.exports = getPrototype;
  }
});

// node_modules/lodash/isPlainObject.js
var require_isPlainObject = __commonJS({
  "node_modules/lodash/isPlainObject.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var getPrototype = require_getPrototype();
    var isObjectLike = require_isObjectLike();
    var objectTag = "[object Object]";
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject2(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty3.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module.exports = isPlainObject2;
  }
});

// node_modules/json-stringify-safe/stringify.js
var require_stringify2 = __commonJS({
  "node_modules/json-stringify-safe/stringify.js"(exports, module) {
    exports = module.exports = stringify;
    exports.getSerialize = serializer;
    function stringify(obj, replacer, spaces, cycleReplacer) {
      return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces);
    }
    function serializer(replacer, cycleReplacer) {
      var stack = [], keys = [];
      if (cycleReplacer == null) cycleReplacer = function(key, value) {
        if (stack[0] === value) return "[Circular ~]";
        return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
      };
      return function(key, value) {
        if (stack.length > 0) {
          var thisPos = stack.indexOf(this);
          ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
          ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
          if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value);
        } else stack.push(value);
        return replacer == null ? value : replacer.call(this, key, value);
      };
    }
  }
});

// node_modules/contentful-sdk-core/node_modules/fast-copy/dist/esm/index.mjs
var toStringFunction = Function.prototype.toString;
var create = Object.create;
var toStringObject = Object.prototype.toString;
var LegacyCache = (
  /** @class */
  function() {
    function LegacyCache2() {
      this._keys = [];
      this._values = [];
    }
    LegacyCache2.prototype.has = function(key) {
      return !!~this._keys.indexOf(key);
    };
    LegacyCache2.prototype.get = function(key) {
      return this._values[this._keys.indexOf(key)];
    };
    LegacyCache2.prototype.set = function(key, value) {
      this._keys.push(key);
      this._values.push(value);
    };
    return LegacyCache2;
  }()
);
function createCacheLegacy() {
  return new LegacyCache();
}
function createCacheModern() {
  return /* @__PURE__ */ new WeakMap();
}
var createCache = typeof WeakMap !== "undefined" ? createCacheModern : createCacheLegacy;
function getCleanClone(prototype) {
  if (!prototype) {
    return create(null);
  }
  var Constructor = prototype.constructor;
  if (Constructor === Object) {
    return prototype === Object.prototype ? {} : create(prototype);
  }
  if (Constructor && ~toStringFunction.call(Constructor).indexOf("[native code]")) {
    try {
      return new Constructor();
    } catch (_a3) {
    }
  }
  return create(prototype);
}
function getRegExpFlagsLegacy(regExp) {
  var flags = "";
  if (regExp.global) {
    flags += "g";
  }
  if (regExp.ignoreCase) {
    flags += "i";
  }
  if (regExp.multiline) {
    flags += "m";
  }
  if (regExp.unicode) {
    flags += "u";
  }
  if (regExp.sticky) {
    flags += "y";
  }
  return flags;
}
function getRegExpFlagsModern(regExp) {
  return regExp.flags;
}
var getRegExpFlags = /test/g.flags === "g" ? getRegExpFlagsModern : getRegExpFlagsLegacy;
function getTagLegacy(value) {
  var type = toStringObject.call(value);
  return type.substring(8, type.length - 1);
}
function getTagModern(value) {
  return value[Symbol.toStringTag] || getTagLegacy(value);
}
var getTag = typeof Symbol !== "undefined" ? getTagModern : getTagLegacy;
var defineProperty = Object.defineProperty;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var _a = Object.prototype;
var hasOwnProperty = _a.hasOwnProperty;
var propertyIsEnumerable = _a.propertyIsEnumerable;
var SUPPORTS_SYMBOL = typeof getOwnPropertySymbols === "function";
function getStrictPropertiesModern(object) {
  return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));
}
var getStrictProperties = SUPPORTS_SYMBOL ? getStrictPropertiesModern : getOwnPropertyNames;
function copyOwnPropertiesStrict(value, clone, state) {
  var properties = getStrictProperties(value);
  for (var index2 = 0, length_1 = properties.length, property = void 0, descriptor = void 0; index2 < length_1; ++index2) {
    property = properties[index2];
    if (property === "callee" || property === "caller") {
      continue;
    }
    descriptor = getOwnPropertyDescriptor(value, property);
    if (!descriptor) {
      clone[property] = state.copier(value[property], state);
      continue;
    }
    if (!descriptor.get && !descriptor.set) {
      descriptor.value = state.copier(descriptor.value, state);
    }
    try {
      defineProperty(clone, property, descriptor);
    } catch (error) {
      clone[property] = descriptor.value;
    }
  }
  return clone;
}
function copyArrayLoose(array, state) {
  var clone = new state.Constructor();
  state.cache.set(array, clone);
  for (var index2 = 0, length_2 = array.length; index2 < length_2; ++index2) {
    clone[index2] = state.copier(array[index2], state);
  }
  return clone;
}
function copyArrayStrict(array, state) {
  var clone = new state.Constructor();
  state.cache.set(array, clone);
  return copyOwnPropertiesStrict(array, clone, state);
}
function copyArrayBuffer(arrayBuffer, _state) {
  return arrayBuffer.slice(0);
}
function copyBlob(blob, _state) {
  return blob.slice(0, blob.size, blob.type);
}
function copyDataView(dataView, state) {
  return new state.Constructor(copyArrayBuffer(dataView.buffer));
}
function copyDate(date, state) {
  return new state.Constructor(date.getTime());
}
function copyMapLoose(map, state) {
  var clone = new state.Constructor();
  state.cache.set(map, clone);
  map.forEach(function(value, key) {
    clone.set(key, state.copier(value, state));
  });
  return clone;
}
function copyMapStrict(map, state) {
  return copyOwnPropertiesStrict(map, copyMapLoose(map, state), state);
}
function copyObjectLooseLegacy(object, state) {
  var clone = getCleanClone(state.prototype);
  state.cache.set(object, clone);
  for (var key in object) {
    if (hasOwnProperty.call(object, key)) {
      clone[key] = state.copier(object[key], state);
    }
  }
  return clone;
}
function copyObjectLooseModern(object, state) {
  var clone = getCleanClone(state.prototype);
  state.cache.set(object, clone);
  for (var key in object) {
    if (hasOwnProperty.call(object, key)) {
      clone[key] = state.copier(object[key], state);
    }
  }
  var symbols = getOwnPropertySymbols(object);
  for (var index2 = 0, length_3 = symbols.length, symbol = void 0; index2 < length_3; ++index2) {
    symbol = symbols[index2];
    if (propertyIsEnumerable.call(object, symbol)) {
      clone[symbol] = state.copier(object[symbol], state);
    }
  }
  return clone;
}
var copyObjectLoose = SUPPORTS_SYMBOL ? copyObjectLooseModern : copyObjectLooseLegacy;
function copyObjectStrict(object, state) {
  var clone = getCleanClone(state.prototype);
  state.cache.set(object, clone);
  return copyOwnPropertiesStrict(object, clone, state);
}
function copyPrimitiveWrapper(primitiveObject, state) {
  return new state.Constructor(primitiveObject.valueOf());
}
function copyRegExp(regExp, state) {
  var clone = new state.Constructor(regExp.source, getRegExpFlags(regExp));
  clone.lastIndex = regExp.lastIndex;
  return clone;
}
function copySelf(value, _state) {
  return value;
}
function copySetLoose(set, state) {
  var clone = new state.Constructor();
  state.cache.set(set, clone);
  set.forEach(function(value) {
    clone.add(state.copier(value, state));
  });
  return clone;
}
function copySetStrict(set, state) {
  return copyOwnPropertiesStrict(set, copySetLoose(set, state), state);
}
var isArray = Array.isArray;
var assign = Object.assign;
var getPrototypeOf = Object.getPrototypeOf || function(obj) {
  return obj.__proto__;
};
var DEFAULT_LOOSE_OPTIONS = {
  array: copyArrayLoose,
  arrayBuffer: copyArrayBuffer,
  blob: copyBlob,
  dataView: copyDataView,
  date: copyDate,
  error: copySelf,
  map: copyMapLoose,
  object: copyObjectLoose,
  regExp: copyRegExp,
  set: copySetLoose
};
var DEFAULT_STRICT_OPTIONS = assign({}, DEFAULT_LOOSE_OPTIONS, {
  array: copyArrayStrict,
  map: copyMapStrict,
  object: copyObjectStrict,
  set: copySetStrict
});
function getTagSpecificCopiers(options) {
  return {
    Arguments: options.object,
    Array: options.array,
    ArrayBuffer: options.arrayBuffer,
    Blob: options.blob,
    Boolean: copyPrimitiveWrapper,
    DataView: options.dataView,
    Date: options.date,
    Error: options.error,
    Float32Array: options.arrayBuffer,
    Float64Array: options.arrayBuffer,
    Int8Array: options.arrayBuffer,
    Int16Array: options.arrayBuffer,
    Int32Array: options.arrayBuffer,
    Map: options.map,
    Number: copyPrimitiveWrapper,
    Object: options.object,
    Promise: copySelf,
    RegExp: options.regExp,
    Set: options.set,
    String: copyPrimitiveWrapper,
    WeakMap: copySelf,
    WeakSet: copySelf,
    Uint8Array: options.arrayBuffer,
    Uint8ClampedArray: options.arrayBuffer,
    Uint16Array: options.arrayBuffer,
    Uint32Array: options.arrayBuffer,
    Uint64Array: options.arrayBuffer
  };
}
function createCopier(options) {
  var normalizedOptions = assign({}, DEFAULT_LOOSE_OPTIONS, options);
  var tagSpecificCopiers = getTagSpecificCopiers(normalizedOptions);
  var array = tagSpecificCopiers.Array, object = tagSpecificCopiers.Object;
  function copier(value, state) {
    state.prototype = state.Constructor = void 0;
    if (!value || typeof value !== "object") {
      return value;
    }
    if (state.cache.has(value)) {
      return state.cache.get(value);
    }
    state.prototype = getPrototypeOf(value);
    state.Constructor = state.prototype && state.prototype.constructor;
    if (!state.Constructor || state.Constructor === Object) {
      return object(value, state);
    }
    if (isArray(value)) {
      return array(value, state);
    }
    var tagSpecificCopier = tagSpecificCopiers[getTag(value)];
    if (tagSpecificCopier) {
      return tagSpecificCopier(value, state);
    }
    return typeof value.then === "function" ? value : object(value, state);
  }
  return function copy2(value) {
    return copier(value, {
      Constructor: void 0,
      cache: createCache(),
      copier,
      prototype: void 0
    });
  };
}
function createStrictCopier(options) {
  return createCopier(assign({}, DEFAULT_STRICT_OPTIONS, options));
}
var copyStrict = createStrictCopier({});
var index = createCopier({});

// node_modules/contentful-sdk-core/dist/create-http-client.js
var import_qs = __toESM(require_lib(), 1);

// node_modules/contentful-sdk-core/dist/async-token.js
function asyncToken(instance, getToken2) {
  instance.interceptors.request.use(function(config) {
    return getToken2().then((accessToken) => {
      config.headers.set("Authorization", `Bearer ${accessToken}`);
      return config;
    });
  });
}

// node_modules/contentful-sdk-core/dist/utils.js
var import_process = __toESM(require_browser(), 1);
function isNode() {
  return typeof import_process.default !== "undefined" && !import_process.default.browser;
}
function isReactNative() {
  return typeof window !== "undefined" && "navigator" in window && "product" in window.navigator && window.navigator.product === "ReactNative";
}
function getNodeVersion() {
  return import_process.default.versions && import_process.default.versions.node ? `v${import_process.default.versions.node}` : import_process.default.version;
}
function getWindow() {
  return window;
}
function noop() {
  return void 0;
}

// node_modules/contentful-sdk-core/dist/rate-limit.js
var delay = (ms) => new Promise((resolve) => {
  setTimeout(resolve, ms);
});
var defaultWait = (attempts) => {
  return Math.pow(Math.SQRT2, attempts);
};
function rateLimit(instance, maxRetry = 5) {
  const { responseLogger = noop, requestLogger = noop } = instance.defaults;
  instance.interceptors.request.use(function(config) {
    requestLogger(config);
    return config;
  }, function(error) {
    requestLogger(error);
    return Promise.reject(error);
  });
  instance.interceptors.response.use(function(response) {
    responseLogger(response);
    return response;
  }, async function(error) {
    const { response } = error;
    const { config } = error;
    responseLogger(error);
    if (!config || !instance.defaults.retryOnError) {
      return Promise.reject(error);
    }
    const doneAttempts = config.attempts || 1;
    if (doneAttempts > maxRetry) {
      error.attempts = config.attempts;
      return Promise.reject(error);
    }
    let retryErrorType = null;
    let wait = defaultWait(doneAttempts);
    if (!response) {
      retryErrorType = "Connection";
    } else if (response.status >= 500 && response.status < 600) {
      retryErrorType = `Server ${response.status}`;
    } else if (response.status === 429) {
      retryErrorType = "Rate limit";
      if (response.headers && error.response.headers["x-contentful-ratelimit-reset"]) {
        wait = response.headers["x-contentful-ratelimit-reset"];
      }
    }
    if (retryErrorType) {
      wait = Math.floor(wait * 1e3 + Math.random() * 200 + 500);
      instance.defaults.logHandler("warning", `${retryErrorType} error occurred. Waiting for ${wait} ms before retrying...`);
      config.attempts = doneAttempts + 1;
      delete config.httpAgent;
      delete config.httpsAgent;
      return delay(wait).then(() => instance(config));
    }
    return Promise.reject(error);
  });
}

// node_modules/contentful-sdk-core/dist/rate-limit-throttle.js
var import_isString = __toESM(require_isString(), 1);

// node_modules/p-throttle/index.js
var AbortError = class extends Error {
  constructor() {
    super("Throttled function aborted");
    this.name = "AbortError";
  }
};
function pThrottle({ limit, interval, strict, onDelay }) {
  if (!Number.isFinite(limit)) {
    throw new TypeError("Expected `limit` to be a finite number");
  }
  if (!Number.isFinite(interval)) {
    throw new TypeError("Expected `interval` to be a finite number");
  }
  const queue = /* @__PURE__ */ new Map();
  let currentTick = 0;
  let activeCount = 0;
  function windowedDelay() {
    const now = Date.now();
    if (now - currentTick > interval) {
      activeCount = 1;
      currentTick = now;
      return 0;
    }
    if (activeCount < limit) {
      activeCount++;
    } else {
      currentTick += interval;
      activeCount = 1;
    }
    return currentTick - now;
  }
  const strictTicks = [];
  function strictDelay() {
    const now = Date.now();
    if (strictTicks.length > 0 && now - strictTicks.at(-1) > interval) {
      strictTicks.length = 0;
    }
    if (strictTicks.length < limit) {
      strictTicks.push(now);
      return 0;
    }
    const nextExecutionTime = strictTicks[0] + interval;
    strictTicks.shift();
    strictTicks.push(nextExecutionTime);
    return Math.max(0, nextExecutionTime - now);
  }
  const getDelay = strict ? strictDelay : windowedDelay;
  return (function_) => {
    const throttled = function(...arguments_) {
      if (!throttled.isEnabled) {
        return (async () => function_.apply(this, arguments_))();
      }
      let timeoutId;
      return new Promise((resolve, reject) => {
        const execute = () => {
          resolve(function_.apply(this, arguments_));
          queue.delete(timeoutId);
        };
        const delay2 = getDelay();
        if (delay2 > 0) {
          timeoutId = setTimeout(execute, delay2);
          queue.set(timeoutId, reject);
          onDelay == null ? void 0 : onDelay(...arguments_);
        } else {
          execute();
        }
      });
    };
    throttled.abort = () => {
      for (const timeout of queue.keys()) {
        clearTimeout(timeout);
        queue.get(timeout)(new AbortError());
      }
      queue.clear();
      strictTicks.splice(0, strictTicks.length);
    };
    throttled.isEnabled = true;
    Object.defineProperty(throttled, "queueSize", {
      get() {
        return queue.size;
      }
    });
    return throttled;
  };
}

// node_modules/contentful-sdk-core/dist/rate-limit-throttle.js
var PERCENTAGE_REGEX = /(?<value>\d+)(%)/;
function calculateLimit(type, max = 7) {
  var _a3;
  let limit = max;
  if (PERCENTAGE_REGEX.test(type)) {
    const groups = (_a3 = type.match(PERCENTAGE_REGEX)) == null ? void 0 : _a3.groups;
    if (groups && groups.value) {
      const percentage = parseInt(groups.value) / 100;
      limit = Math.round(max * percentage);
    }
  }
  return Math.min(30, Math.max(1, limit));
}
function createThrottle(limit, logger) {
  logger("info", `Throttle request to ${limit}/s`);
  return pThrottle({
    limit,
    interval: 1e3,
    strict: false
  });
}
var rate_limit_throttle_default = (axiosInstance, type = "auto") => {
  const { logHandler = noop } = axiosInstance.defaults;
  let limit = (0, import_isString.default)(type) ? calculateLimit(type) : calculateLimit("auto", type);
  let throttle = createThrottle(limit, logHandler);
  let isCalculated = false;
  let requestInterceptorId = axiosInstance.interceptors.request.use((config) => {
    return throttle(() => config)();
  }, function(error) {
    return Promise.reject(error);
  });
  const responseInterceptorId = axiosInstance.interceptors.response.use((response) => {
    if (!isCalculated && (0, import_isString.default)(type) && (type === "auto" || PERCENTAGE_REGEX.test(type)) && response.headers && response.headers["x-contentful-ratelimit-second-limit"]) {
      const rawLimit = parseInt(response.headers["x-contentful-ratelimit-second-limit"]);
      const nextLimit = calculateLimit(type, rawLimit);
      if (nextLimit !== limit) {
        if (requestInterceptorId) {
          axiosInstance.interceptors.request.eject(requestInterceptorId);
        }
        limit = nextLimit;
        throttle = createThrottle(nextLimit, logHandler);
        requestInterceptorId = axiosInstance.interceptors.request.use((config) => {
          return throttle(() => config)();
        }, function(error) {
          return Promise.reject(error);
        });
      }
      isCalculated = true;
    }
    return response;
  }, function(error) {
    return Promise.reject(error);
  });
  return () => {
    axiosInstance.interceptors.request.eject(requestInterceptorId);
    axiosInstance.interceptors.response.eject(responseInterceptorId);
  };
};

// node_modules/contentful-sdk-core/dist/create-http-client.js
var HOST_REGEX = /^(?!\w+:\/\/)([^\s:]+\.?[^\s:]+)(?::(\d+))?(?!:)$/;
function copyHttpClientParams(options) {
  const copiedOptions = index(options);
  copiedOptions.httpAgent = options.httpAgent;
  copiedOptions.httpsAgent = options.httpsAgent;
  return copiedOptions;
}
function createHttpClient(axios, options) {
  const defaultConfig = {
    insecure: false,
    retryOnError: true,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    logHandler: (level, data) => {
      if (level === "error" && data) {
        const title = [data.name, data.message].filter((a2) => a2).join(" - ");
        console.error(`[error] ${title}`);
        console.error(data);
        return;
      }
      console.log(`[${level}] ${data}`);
    },
    // Passed to axios
    headers: {},
    httpAgent: false,
    httpsAgent: false,
    timeout: 3e4,
    throttle: 0,
    basePath: "",
    adapter: void 0,
    maxContentLength: 1073741824,
    // 1GB
    maxBodyLength: 1073741824
    // 1GB
  };
  const config = {
    ...defaultConfig,
    ...options
  };
  if (!config.accessToken) {
    const missingAccessTokenError = new TypeError("Expected parameter accessToken");
    config.logHandler("error", missingAccessTokenError);
    throw missingAccessTokenError;
  }
  const protocol = config.insecure ? "http" : "https";
  const space = config.space ? `${config.space}/` : "";
  let hostname = config.defaultHostname;
  let port = config.insecure ? 80 : 443;
  if (config.host && HOST_REGEX.test(config.host)) {
    const parsed = config.host.split(":");
    if (parsed.length === 2) {
      ;
      [hostname, port] = parsed;
    } else {
      hostname = parsed[0];
    }
  }
  if (config.basePath) {
    config.basePath = `/${config.basePath.split("/").filter(Boolean).join("/")}`;
  }
  const baseURL = options.baseURL || `${protocol}://${hostname}:${port}${config.basePath}/spaces/${space}`;
  if (!config.headers.Authorization && typeof config.accessToken !== "function") {
    config.headers.Authorization = "Bearer " + config.accessToken;
  }
  const axiosOptions = {
    // Axios
    baseURL,
    headers: config.headers,
    httpAgent: config.httpAgent,
    httpsAgent: config.httpsAgent,
    proxy: config.proxy,
    timeout: config.timeout,
    adapter: config.adapter,
    maxContentLength: config.maxContentLength,
    maxBodyLength: config.maxBodyLength,
    paramsSerializer: {
      serialize: (params) => {
        return import_qs.default.stringify(params);
      }
    },
    // Contentful
    logHandler: config.logHandler,
    responseLogger: config.responseLogger,
    requestLogger: config.requestLogger,
    retryOnError: config.retryOnError
  };
  const instance = axios.create(axiosOptions);
  instance.httpClientParams = options;
  instance.cloneWithNewParams = function(newParams) {
    return createHttpClient(axios, {
      ...copyHttpClientParams(options),
      ...newParams
    });
  };
  if (config.onBeforeRequest) {
    instance.interceptors.request.use(config.onBeforeRequest);
  }
  if (typeof config.accessToken === "function") {
    asyncToken(instance, config.accessToken);
  }
  if (config.throttle) {
    rate_limit_throttle_default(instance, config.throttle);
  }
  rateLimit(instance, config.retryLimit);
  if (config.onError) {
    instance.interceptors.response.use((response) => response, config.onError);
  }
  return instance;
}

// node_modules/contentful-sdk-core/dist/create-request-config.js
function createRequestConfig({ query }) {
  const config = {};
  delete query.resolveLinks;
  config.params = index(query);
  return config;
}

// node_modules/contentful-sdk-core/dist/freeze-sys.js
function deepFreeze(object) {
  const propNames = Object.getOwnPropertyNames(object);
  for (const name of propNames) {
    const value = object[name];
    if (value && typeof value === "object") {
      deepFreeze(value);
    }
  }
  return Object.freeze(object);
}
function freezeSys(obj) {
  deepFreeze(obj.sys || {});
  return obj;
}

// node_modules/contentful-sdk-core/dist/get-user-agent.js
var import_process2 = __toESM(require_browser(), 1);
function getBrowserOS() {
  const win = getWindow();
  if (!win) {
    return null;
  }
  const userAgent = win.navigator.userAgent;
  const platform = win.navigator.platform;
  const macosPlatforms = ["Macintosh", "MacIntel", "MacPPC", "Mac68K"];
  const windowsPlatforms = ["Win32", "Win64", "Windows", "WinCE"];
  const iosPlatforms = ["iPhone", "iPad", "iPod"];
  if (macosPlatforms.indexOf(platform) !== -1) {
    return "macOS";
  } else if (iosPlatforms.indexOf(platform) !== -1) {
    return "iOS";
  } else if (windowsPlatforms.indexOf(platform) !== -1) {
    return "Windows";
  } else if (/Android/.test(userAgent)) {
    return "Android";
  } else if (/Linux/.test(platform)) {
    return "Linux";
  }
  return null;
}
function getNodeOS() {
  const platform = import_process2.default.platform || "linux";
  const version = import_process2.default.version || "0.0.0";
  const platformMap = {
    android: "Android",
    aix: "Linux",
    darwin: "macOS",
    freebsd: "Linux",
    linux: "Linux",
    openbsd: "Linux",
    sunos: "Linux",
    win32: "Windows"
  };
  if (platform in platformMap) {
    return `${platformMap[platform] || "Linux"}/${version}`;
  }
  return null;
}
function getUserAgentHeader(sdk, application, integration, feature) {
  const headerParts = [];
  if (application) {
    headerParts.push(`app ${application}`);
  }
  if (integration) {
    headerParts.push(`integration ${integration}`);
  }
  if (feature) {
    headerParts.push("feature " + feature);
  }
  headerParts.push(`sdk ${sdk}`);
  let platform = null;
  try {
    if (isReactNative()) {
      platform = getBrowserOS();
      headerParts.push("platform ReactNative");
    } else if (isNode()) {
      platform = getNodeOS();
      headerParts.push(`platform node.js/${getNodeVersion()}`);
    } else {
      platform = getBrowserOS();
      headerParts.push("platform browser");
    }
  } catch (e) {
    platform = null;
  }
  if (platform) {
    headerParts.push(`os ${platform}`);
  }
  return `${headerParts.filter((item) => item !== "").join("; ")};`;
}

// node_modules/contentful-sdk-core/dist/to-plain-object.js
function toPlainObject(data) {
  return Object.defineProperty(data, "toPlainObject", {
    enumerable: false,
    configurable: false,
    writable: false,
    value: function() {
      return index(this);
    }
  });
}

// node_modules/contentful-sdk-core/dist/error-handler.js
var import_isPlainObject = __toESM(require_isPlainObject(), 1);
function errorHandler(errorResponse) {
  var _a3;
  const { config, response } = errorResponse;
  let errorName;
  if (config && config.headers && config.headers["Authorization"]) {
    const token = `...${config.headers["Authorization"].toString().substr(-5)}`;
    config.headers["Authorization"] = `Bearer ${token}`;
  }
  if (!(0, import_isPlainObject.default)(response) || !(0, import_isPlainObject.default)(config)) {
    throw errorResponse;
  }
  const data = response == null ? void 0 : response.data;
  const errorData = {
    status: response == null ? void 0 : response.status,
    statusText: response == null ? void 0 : response.statusText,
    message: "",
    details: {}
  };
  if (config && (0, import_isPlainObject.default)(config)) {
    errorData.request = {
      url: config.url,
      headers: config.headers,
      method: config.method,
      payloadData: config.data
    };
  }
  if (data && typeof data === "object") {
    if ("requestId" in data) {
      errorData.requestId = data.requestId || "UNKNOWN";
    }
    if ("message" in data) {
      errorData.message = data.message || "";
    }
    if ("details" in data) {
      errorData.details = data.details || {};
    }
    errorName = (_a3 = data.sys) == null ? void 0 : _a3.id;
  }
  const error = new Error();
  error.name = errorName && errorName !== "Unknown" ? errorName : `${response == null ? void 0 : response.status} ${response == null ? void 0 : response.statusText}`;
  try {
    error.message = JSON.stringify(errorData, null, "  ");
  } catch {
    error.message = (errorData == null ? void 0 : errorData.message) ?? "";
  }
  throw error;
}

// node_modules/contentful/dist/esm/create-global-options.js
function createGlobalOptions(globalSettings) {
  return function getGlobalOptions(query) {
    return Object.assign({}, globalSettings, query);
  };
}

// node_modules/@contentful/content-source-maps/dist/index.js
var R = { 0: 8203, 1: 8204, 2: 8205, 3: 8290, 4: 8291, 5: 8288, 6: 65279, 7: 8289, 8: 119155, 9: 119156, a: 119157, b: 119158, c: 119159, d: 119160, e: 119161, f: 119162 };
var b = { 0: 8203, 1: 8204, 2: 8205, 3: 65279 };
var V = new Array(4).fill(String.fromCodePoint(b[0])).join("");
function _(e) {
  let t = JSON.stringify(e);
  return `${V}${Array.from(t).map((o) => {
    let n = o.charCodeAt(0);
    if (n > 255) throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${t} on character ${o} (${n})`);
    return Array.from(n.toString(4).padStart(4, "0")).map((r) => String.fromCodePoint(b[r])).join("");
  }).join("")}`;
}
function D(e) {
  return !Number.isNaN(Number(e)) || /[a-z]/i.test(e) && !/\d+(?:[-:\/]\d+){2}(?:T\d+(?:[-:\/]\d+){1,2}(\.\d+)?Z?)?/.test(e) ? false : !!Date.parse(e);
}
function Q(e) {
  try {
    new URL(e, e.startsWith("/") ? "https://acme.com" : void 0);
  } catch (t) {
    return false;
  }
  return true;
}
function z(e, t, o = "auto") {
  return o === true || o === "auto" && (D(e) || Q(e)) ? e : `${e}${_(t)}`;
}
var Z = Object.fromEntries(Object.entries(b).map((e) => e.reverse()));
var k = Object.fromEntries(Object.entries(R).map((e) => e.reverse()));
var G = `${Object.values(R).map((e) => `\\u{${e.toString(16)}}`).join("")}`;
var O = new RegExp(`[${G}]{4,}`, "gu");
function T(e, t) {
  return z(e, t);
}
var q = Object.prototype.hasOwnProperty;
var ee = Object.prototype.toString;
var te = function(t, o, n) {
  if (ee.call(o) !== "[object Function]")
    throw new TypeError("iterator must be a function");
  var r = t.length;
  if (r === +r)
    for (var s = 0; s < r; s++)
      o.call(n, t[s], s, t);
  else
    for (var i in t)
      q.call(t, i) && o.call(n, t[i], i, t);
};
var ne = te;
var y = a;
function a(e, t, o) {
  if (arguments.length === 3)
    return a.set(e, t, o);
  if (arguments.length === 2)
    return a.get(e, t);
  var n = a.bind(a, e);
  for (var r in a)
    a.hasOwnProperty(r) && (n[r] = a[r].bind(n, e));
  return n;
}
a.get = function(t, o) {
  for (var n = Array.isArray(o) ? o : a.parse(o), r = 0; r < n.length; ++r) {
    var s = n[r];
    if (!(typeof t == "object" && s in t))
      throw new Error("Invalid reference token: " + s);
    t = t[s];
  }
  return t;
};
a.set = function(t, o, n) {
  var r = Array.isArray(o) ? o : a.parse(o), s = r[0];
  if (r.length === 0)
    throw Error("Can not set the root object");
  for (var i = 0; i < r.length - 1; ++i) {
    var c = r[i];
    typeof c != "string" && typeof c != "number" && (c = String(c)), !(c === "__proto__" || c === "constructor" || c === "prototype") && (c === "-" && Array.isArray(t) && (c = t.length), s = r[i + 1], c in t || (s.match(/^(\d+|-)$/) ? t[c] = [] : t[c] = {}), t = t[c]);
  }
  return s === "-" && Array.isArray(t) && (s = t.length), t[s] = n, this;
};
a.remove = function(e, t) {
  var o = Array.isArray(t) ? t : a.parse(t), n = o[o.length - 1];
  if (n === void 0)
    throw new Error('Invalid JSON pointer for remove: "' + t + '"');
  var r = a.get(e, o.slice(0, -1));
  if (Array.isArray(r)) {
    var s = +n;
    if (n === "" && isNaN(s))
      throw new Error('Invalid array index: "' + n + '"');
    Array.prototype.splice.call(r, s, 1);
  } else
    delete r[n];
};
a.dict = function(t, o) {
  var n = {};
  return a.walk(t, function(r, s) {
    n[s] = r;
  }, o), n;
};
a.walk = function(t, o, n) {
  var r = [];
  n = n || function(s) {
    var i = Object.prototype.toString.call(s);
    return i === "[object Object]" || i === "[object Array]";
  }, function s(i) {
    ne(i, function(c, u) {
      r.push(String(u)), n(c) ? s(c) : o(c, a.compile(r)), r.pop();
    });
  }(t);
};
a.has = function(t, o) {
  try {
    a.get(t, o);
  } catch (n) {
    return false;
  }
  return true;
};
a.escape = function(t) {
  return t.toString().replace(/~/g, "~0").replace(/\//g, "~1");
};
a.unescape = function(t) {
  return t.replace(/~1/g, "/").replace(/~0/g, "~");
};
a.parse = function(t) {
  if (t === "")
    return [];
  if (t.charAt(0) !== "/")
    throw new Error("Invalid JSON pointer: " + t);
  return t.substring(1).split(/\//).map(a.unescape);
};
a.compile = function(t) {
  return t.length === 0 ? "" : "/" + t.map(a.escape).join("/");
};
var re = ({
  pointer: e,
  mappings: t,
  data: o,
  hiddenStrings: n
}) => {
  const r = t[e];
  delete t[e];
  const s = F(o, e);
  for (const i of s) {
    t[i] = r;
    const c = y.get(o, i), u = T(c, n);
    y.set(o, i, u);
  }
};
var F = (e, t = "") => {
  const o = [], n = y.get(e, t);
  if (n.content)
    for (let r = 0; r < n.content.length; r++)
      n.content[r].nodeType === "text" ? o.push(`${t}/content/${r}/value`) : o.push(...F(e, `${t}/content/${r}`));
  return o;
};
var x = ({
  entityId: e,
  entityType: t,
  space: o,
  environment: n,
  field: r,
  locale: s,
  editorInterface: i,
  fieldType: c,
  targetOrigin: u,
  platform: f
}) => {
  const d = {
    origin: "contentful.com",
    href: `${`${u || "https://app.contentful.com"}/spaces/${o}/environments/${n}`}/${t === "Entry" ? "entries" : "assets"}/${e}/?focusedField=${r}&focusedLocale=${s}&source=vercel-content-link`,
    contentful: {
      editorInterface: i,
      fieldType: c
    }
  };
  return f === "vercel" && delete d.contentful, d;
};
var W = (e) => ["builtin", "sidebar-builtin", "editor-builtin"].includes(e);
var U = (e) => oe.includes(e);
function j(e) {
  if (typeof structuredClone == "function")
    return structuredClone(e);
  try {
    return JSON.parse(JSON.stringify(e));
  } catch (t) {
    return console.warn("Failed to clone data:", e, t), e;
  }
}
var oe = [
  "singleLine",
  "tagEditor",
  "listInput",
  "checkbox",
  "richTextEditor",
  "multipleLine"
];
function C(e, t, o, n, r, s, i) {
  const c = i ? t[i] : t;
  switch (e) {
    case "Symbol": {
      const u = T(c, o);
      y.set(n, r, u);
      break;
    }
    case "Text": {
      const u = T(c, o);
      y.set(n, r, u);
      break;
    }
    case "RichText": {
      re({
        pointer: "",
        mappings: s,
        data: c,
        hiddenStrings: o
      });
      break;
    }
    case "Array": {
      const u = c.map((f) => typeof f == "string" ? T(f, o) : f);
      y.set(n, r, u);
      break;
    }
  }
}
var $ = (e, t, o, n, r) => {
  if (!e.fields)
    return;
  const { contentSourceMaps: s } = e.sys;
  if (!s) {
    console.error("Content source maps data is missing");
    return;
  }
  const { mappings: i } = s;
  for (const c in i) {
    const { source: u } = i[c], f = e.sys.space.sys.id, p = e.sys.environment.sys.id, g = e.sys.id, v = e.sys.type, h = t[u.fieldType], d = o[u.editorInterface];
    if (W(d.widgetNamespace) && !U(d.widgetId))
      continue;
    const l = c.startsWith("/") ? c : `/${c}`;
    if (y.has(e, l)) {
      const m = y.get(e, l);
      if (m === null)
        return;
      const S = l.split("/").pop();
      if (!S) {
        console.error("Field name could not be extracted from the pointer", l);
        return;
      }
      const A = e.sys.locale;
      if (A) {
        const E = x({
          entityId: g,
          entityType: v,
          space: f,
          environment: p,
          field: S,
          locale: A,
          editorInterface: d,
          fieldType: h,
          targetOrigin: n,
          platform: r
        });
        C(h, m, E, e, l, i);
      } else
        Object.keys(m).forEach((w) => {
          const I = x({
            entityId: g,
            entityType: v,
            space: f,
            environment: p,
            field: S,
            locale: w,
            editorInterface: d,
            fieldType: h,
            targetOrigin: n,
            platform: r
          });
          C(
            h,
            m,
            I,
            e,
            `${l}/${w}`,
            i,
            w
          );
        });
    }
  }
};
var ue = (e, t, o) => {
  var r;
  const n = j(
    e
  );
  if (n.sys && "items" in n) {
    const s = n;
    if (!((r = s.sys) != null && r.contentSourceMapsLookup))
      return console.error("Content source maps lookup data is missing"), s;
    const {
      contentSourceMapsLookup: { fieldTypes: i, editorInterfaces: c }
    } = s.sys, { items: u, includes: f } = s;
    u.forEach(
      (p) => $(p, i, c, t, o)
    ), f && f.Entry && f.Entry.forEach(
      (p) => $(p, i, c, t, o)
    ), f && f.Asset && f.Asset.forEach(
      (p) => $(p, i, c, t, o)
    );
  } else {
    const s = n;
    if (!s.sys.contentSourceMapsLookup)
      return console.error("Content source maps lookup data is missing"), s;
    $(
      s,
      s.sys.contentSourceMapsLookup.fieldTypes,
      s.sys.contentSourceMapsLookup.editorInterfaces,
      t,
      o
    );
  }
  return n;
};

// node_modules/fast-copy/dist/fast-copy.esm.js
var toStringFunction2 = Function.prototype.toString;
var create2 = Object.create;
var defineProperty2 = Object.defineProperty;
var getOwnPropertyDescriptor2 = Object.getOwnPropertyDescriptor;
var getOwnPropertyNames2 = Object.getOwnPropertyNames;
var getOwnPropertySymbols2 = Object.getOwnPropertySymbols;
var getPrototypeOf$1 = Object.getPrototypeOf;
var _a2 = Object.prototype;
var hasOwnProperty2 = _a2.hasOwnProperty;
var propertyIsEnumerable2 = _a2.propertyIsEnumerable;
var SYMBOL_PROPERTIES = typeof getOwnPropertySymbols2 === "function";
var WEAK_MAP = typeof WeakMap === "function";
var createCache2 = function() {
  if (WEAK_MAP) {
    return function() {
      return /* @__PURE__ */ new WeakMap();
    };
  }
  var Cache = (
    /** @class */
    function() {
      function Cache2() {
        this._keys = [];
        this._values = [];
      }
      Cache2.prototype.has = function(key) {
        return !!~this._keys.indexOf(key);
      };
      Cache2.prototype.get = function(key) {
        return this._values[this._keys.indexOf(key)];
      };
      Cache2.prototype.set = function(key, value) {
        this._keys.push(key);
        this._values.push(value);
      };
      return Cache2;
    }()
  );
  return function() {
    return new Cache();
  };
}();
var getCleanClone2 = function(object, realm) {
  var prototype = object.__proto__ || getPrototypeOf$1(object);
  if (!prototype) {
    return create2(null);
  }
  var Constructor = prototype.constructor;
  if (Constructor === realm.Object) {
    return prototype === realm.Object.prototype ? {} : create2(prototype);
  }
  if (~toStringFunction2.call(Constructor).indexOf("[native code]")) {
    try {
      return new Constructor();
    } catch (_a3) {
    }
  }
  return create2(prototype);
};
var getObjectCloneLoose = function(object, realm, handleCopy, cache) {
  var clone = getCleanClone2(object, realm);
  cache.set(object, clone);
  for (var key in object) {
    if (hasOwnProperty2.call(object, key)) {
      clone[key] = handleCopy(object[key], cache);
    }
  }
  if (SYMBOL_PROPERTIES) {
    var symbols = getOwnPropertySymbols2(object);
    for (var index2 = 0, length_1 = symbols.length, symbol = void 0; index2 < length_1; ++index2) {
      symbol = symbols[index2];
      if (propertyIsEnumerable2.call(object, symbol)) {
        clone[symbol] = handleCopy(object[symbol], cache);
      }
    }
  }
  return clone;
};
var getObjectCloneStrict = function(object, realm, handleCopy, cache) {
  var clone = getCleanClone2(object, realm);
  cache.set(object, clone);
  var properties = SYMBOL_PROPERTIES ? getOwnPropertyNames2(object).concat(getOwnPropertySymbols2(object)) : getOwnPropertyNames2(object);
  for (var index2 = 0, length_2 = properties.length, property = void 0, descriptor = void 0; index2 < length_2; ++index2) {
    property = properties[index2];
    if (property !== "callee" && property !== "caller") {
      descriptor = getOwnPropertyDescriptor2(object, property);
      if (descriptor) {
        if (!descriptor.get && !descriptor.set) {
          descriptor.value = handleCopy(object[property], cache);
        }
        try {
          defineProperty2(clone, property, descriptor);
        } catch (error) {
          clone[property] = descriptor.value;
        }
      } else {
        clone[property] = handleCopy(object[property], cache);
      }
    }
  }
  return clone;
};
var getRegExpFlags2 = function(regExp) {
  var flags = "";
  if (regExp.global) {
    flags += "g";
  }
  if (regExp.ignoreCase) {
    flags += "i";
  }
  if (regExp.multiline) {
    flags += "m";
  }
  if (regExp.unicode) {
    flags += "u";
  }
  if (regExp.sticky) {
    flags += "y";
  }
  return flags;
};
var isArray2 = Array.isArray;
var getPrototypeOf2 = Object.getPrototypeOf;
var GLOBAL_THIS = function() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  if (console && console.error) {
    console.error('Unable to locate global object, returning "this".');
  }
  return this;
}();
function copy(value, options) {
  var isStrict = !!(options && options.isStrict);
  var realm = options && options.realm || GLOBAL_THIS;
  var getObjectClone = isStrict ? getObjectCloneStrict : getObjectCloneLoose;
  var handleCopy = function(value2, cache) {
    if (!value2 || typeof value2 !== "object") {
      return value2;
    }
    if (cache.has(value2)) {
      return cache.get(value2);
    }
    var prototype = value2.__proto__ || getPrototypeOf2(value2);
    var Constructor = prototype && prototype.constructor;
    if (!Constructor || Constructor === realm.Object) {
      return getObjectClone(value2, realm, handleCopy, cache);
    }
    var clone;
    if (isArray2(value2)) {
      if (isStrict) {
        return getObjectCloneStrict(value2, realm, handleCopy, cache);
      }
      clone = new Constructor();
      cache.set(value2, clone);
      for (var index2 = 0, length_1 = value2.length; index2 < length_1; ++index2) {
        clone[index2] = handleCopy(value2[index2], cache);
      }
      return clone;
    }
    if (value2 instanceof realm.Date) {
      return new Constructor(value2.getTime());
    }
    if (value2 instanceof realm.RegExp) {
      clone = new Constructor(value2.source, value2.flags || getRegExpFlags2(value2));
      clone.lastIndex = value2.lastIndex;
      return clone;
    }
    if (realm.Map && value2 instanceof realm.Map) {
      clone = new Constructor();
      cache.set(value2, clone);
      value2.forEach(function(value3, key) {
        clone.set(key, handleCopy(value3, cache));
      });
      return clone;
    }
    if (realm.Set && value2 instanceof realm.Set) {
      clone = new Constructor();
      cache.set(value2, clone);
      value2.forEach(function(value3) {
        clone.add(handleCopy(value3, cache));
      });
      return clone;
    }
    if (realm.Blob && value2 instanceof realm.Blob) {
      return value2.slice(0, value2.size, value2.type);
    }
    if (realm.Buffer && realm.Buffer.isBuffer(value2)) {
      clone = realm.Buffer.allocUnsafe ? realm.Buffer.allocUnsafe(value2.length) : new Constructor(value2.length);
      cache.set(value2, clone);
      value2.copy(clone);
      return clone;
    }
    if (realm.ArrayBuffer) {
      if (realm.ArrayBuffer.isView(value2)) {
        clone = new Constructor(value2.buffer.slice(0));
        cache.set(value2, clone);
        return clone;
      }
      if (value2 instanceof realm.ArrayBuffer) {
        clone = value2.slice(0);
        cache.set(value2, clone);
        return clone;
      }
    }
    if (
      // promise-like
      typeof value2.then === "function" || // errors
      value2 instanceof Error || // weakmaps
      realm.WeakMap && value2 instanceof realm.WeakMap || // weaksets
      realm.WeakSet && value2 instanceof realm.WeakSet
    ) {
      return value2;
    }
    return getObjectClone(value2, realm, handleCopy, cache);
  };
  return handleCopy(value, createCache2());
}
copy.default = copy;
copy.strict = function strictCopy(value, options) {
  return copy(value, {
    isStrict: true,
    realm: options ? options.realm : void 0
  });
};

// node_modules/contentful-resolve-response/dist/esm/index.js
var UNRESOLVED_LINK = {};
var isLink = (object) => object && object.sys && object.sys.type === "Link";
var isResourceLink = (object) => object && object.sys && object.sys.type === "ResourceLink";
var makeEntityMapKeys = (sys) => {
  if (sys.space && sys.environment) {
    return [`${sys.type}!${sys.id}`, `${sys.space.sys.id}!${sys.environment.sys.id}!${sys.type}!${sys.id}`];
  }
  return [`${sys.type}!${sys.id}`];
};
var lookupInEntityMap = (entityMap, linkData) => {
  const { entryId, linkType, spaceId, environmentId } = linkData;
  if (spaceId && environmentId) {
    return entityMap.get(`${spaceId}!${environmentId}!${linkType}!${entryId}`);
  }
  return entityMap.get(`${linkType}!${entryId}`);
};
var getIdsFromUrn = (urn) => {
  const regExp = /.*:spaces\/([^/]+)(?:\/environments\/([^/]+))?\/entries\/([^/]+)$/;
  if (!regExp.test(urn)) {
    return void 0;
  }
  const [_2, spaceId, environmentId = "master", entryId] = urn.match(regExp);
  return { spaceId, environmentId, entryId };
};
var getResolvedLink = (entityMap, link) => {
  const { type, linkType } = link.sys;
  if (type === "ResourceLink") {
    if (!linkType.startsWith("Contentful:")) {
      return link;
    }
    const { urn } = link.sys;
    const { spaceId, environmentId, entryId: entryId2 } = getIdsFromUrn(urn);
    const extractedLinkType = linkType.split(":")[1];
    return lookupInEntityMap(entityMap, {
      linkType: extractedLinkType,
      entryId: entryId2,
      spaceId,
      environmentId
    }) || UNRESOLVED_LINK;
  }
  const { id: entryId } = link.sys;
  return lookupInEntityMap(entityMap, { linkType, entryId }) || UNRESOLVED_LINK;
};
var cleanUpUnresolvedLinks = (input) => {
  if (Array.isArray(input)) {
    return input.filter((val) => val !== UNRESOLVED_LINK);
  }
  for (const key in input) {
    if (input[key] === UNRESOLVED_LINK) {
      delete input[key];
    }
  }
  return input;
};
var normalizeLink = (entityMap, link, removeUnresolved) => {
  const resolvedLink = getResolvedLink(entityMap, link);
  if (resolvedLink === UNRESOLVED_LINK) {
    return removeUnresolved ? resolvedLink : link;
  }
  return resolvedLink;
};
var maybeNormalizeLink = (entityMap, maybeLink, removeUnresolved) => {
  if (Array.isArray(maybeLink)) {
    return maybeLink.reduce((acc, link) => {
      const normalizedLink = maybeNormalizeLink(entityMap, link, removeUnresolved);
      if (removeUnresolved && normalizedLink === UNRESOLVED_LINK) {
        return acc;
      }
      acc.push(normalizedLink);
      return acc;
    }, []);
  } else if (typeof maybeLink === "object") {
    if (isLink(maybeLink) || isResourceLink(maybeLink)) {
      return normalizeLink(entityMap, maybeLink, removeUnresolved);
    }
  }
  return maybeLink;
};
var walkMutate = (input, predicate, mutator, removeUnresolved) => {
  if (predicate(input)) {
    return mutator(input);
  }
  if (input && typeof input === "object") {
    for (const key in input) {
      if (input.hasOwnProperty(key)) {
        input[key] = walkMutate(input[key], predicate, mutator, removeUnresolved);
      }
    }
    if (removeUnresolved) {
      input = cleanUpUnresolvedLinks(input);
    }
  }
  return input;
};
var makeEntryObject = (item, itemEntryPoints) => {
  if (!Array.isArray(itemEntryPoints)) {
    return item;
  }
  const entryPoints = Object.keys(item).filter((ownKey) => itemEntryPoints.indexOf(ownKey) !== -1);
  return entryPoints.reduce((entryObj, entryPoint) => {
    entryObj[entryPoint] = item[entryPoint];
    return entryObj;
  }, {});
};
var normalizeFromEntryPoint = (entityMap, entryPoint, removeUnresolved) => {
  if (!entryPoint) {
    return void 0;
  }
  if (Array.isArray(entryPoint)) {
    return maybeNormalizeLink(entityMap, entryPoint, removeUnresolved);
  } else if (typeof entryPoint === "object") {
    return Object.entries(entryPoint).reduce((acc, [key, val]) => {
      const normalizedLink = maybeNormalizeLink(entityMap, val, removeUnresolved);
      if (removeUnresolved && normalizedLink === UNRESOLVED_LINK) {
        return acc;
      }
      acc[key] = normalizedLink;
      return acc;
    }, {});
  }
};
var resolveResponse = (response, options) => {
  options || (options = {});
  if (!response.items) {
    return [];
  }
  const responseClone = copy(response);
  const allIncludes = Object.keys(responseClone.includes || {}).reduce((all, type) => [...all, ...response.includes[type]], []);
  const allEntries = [...responseClone.items, ...allIncludes].filter((entity) => Boolean(entity.sys));
  const entityMap = new Map(allEntries.reduce((acc, entity) => {
    const entries = makeEntityMapKeys(entity.sys).map((key) => [key, entity]);
    acc.push(...entries);
    return acc;
  }, []));
  allEntries.forEach((item) => {
    if (options.itemEntryPoints && options.itemEntryPoints.length) {
      for (const entryPoint of options.itemEntryPoints) {
        item[entryPoint] = normalizeFromEntryPoint(entityMap, item[entryPoint], options.removeUnresolved);
      }
    } else {
      const entryObject = makeEntryObject(item, options.itemEntryPoints);
      Object.assign(item, walkMutate(entryObject, (x2) => isLink(x2) || isResourceLink(x2), (link) => normalizeLink(entityMap, link, options.removeUnresolved), options.removeUnresolved));
    }
  });
  return responseClone.items;
};
var esm_default = resolveResponse;

// node_modules/contentful/dist/esm/mixins/stringify-safe.js
var import_json_stringify_safe = __toESM(require_stringify2(), 1);
function mixinStringifySafe(data) {
  return Object.defineProperty(data, "stringifySafe", {
    enumerable: false,
    configurable: false,
    writable: false,
    value: function(serializer = null, indent = "") {
      return (0, import_json_stringify_safe.default)(this, serializer, indent, (key, value) => {
        return {
          sys: {
            type: "Link",
            linkType: "Entry",
            id: value.sys.id,
            circular: true
          }
        };
      });
    }
  });
}

// node_modules/contentful/dist/esm/paged-sync.js
async function pagedSync(http, query, options) {
  if (!query || !query.initial && !query.nextSyncToken && !query.nextPageToken) {
    throw new Error("Please provide one of `initial`, `nextSyncToken` or `nextPageToken` parameters for syncing");
  }
  if (query["content_type"] && !query.type) {
    query.type = "Entry";
  } else if (query["content_type"] && query.type && query.type !== "Entry") {
    throw new Error("When using the `content_type` filter your `type` parameter cannot be different from `Entry`.");
  }
  const defaultOptions = {
    withoutLinkResolution: false,
    withoutUnresolvableLinks: false,
    paginate: true
  };
  const { withoutLinkResolution, withoutUnresolvableLinks, paginate } = Object.assign(Object.assign({}, defaultOptions), options);
  const response = await getSyncPage(http, [], query, { paginate });
  if (!withoutLinkResolution) {
    response.items = esm_default(response, {
      removeUnresolved: withoutUnresolvableLinks,
      itemEntryPoints: ["fields"]
    });
  }
  const mappedResponseItems = mapResponseItems(response.items);
  if (response.nextSyncToken) {
    mappedResponseItems.nextSyncToken = response.nextSyncToken;
  }
  if (response.nextPageToken) {
    mappedResponseItems.nextPageToken = response.nextPageToken;
  }
  return freezeSys(mixinStringifySafe(toPlainObject(mappedResponseItems)));
}
function mapResponseItems(items) {
  const reducer = (type) => {
    return (accumulated, item) => {
      if (item.sys.type === type) {
        accumulated.push(toPlainObject(item));
      }
      return accumulated;
    };
  };
  return {
    entries: items.reduce(reducer("Entry"), []),
    assets: items.reduce(reducer("Asset"), []),
    deletedEntries: items.reduce(reducer("DeletedEntry"), []),
    deletedAssets: items.reduce(reducer("DeletedAsset"), [])
  };
}
function createRequestQuery(originalQuery) {
  if (originalQuery.nextPageToken) {
    return { sync_token: originalQuery.nextPageToken };
  }
  if (originalQuery.nextSyncToken) {
    return { sync_token: originalQuery.nextSyncToken };
  }
  if (originalQuery.sync_token) {
    return { sync_token: originalQuery.sync_token };
  }
  return originalQuery;
}
async function getSyncPage(http, items, query, { paginate }) {
  const requestQuery = createRequestQuery(query);
  const response = await http.get("sync", createRequestConfig({ query: requestQuery }));
  const data = response.data || {};
  items = items.concat(data.items || []);
  if (data.nextPageUrl) {
    if (paginate) {
      delete requestQuery.initial;
      requestQuery.sync_token = getToken(data.nextPageUrl);
      return getSyncPage(http, items, requestQuery, { paginate });
    }
    return {
      items,
      nextPageToken: getToken(data.nextPageUrl)
    };
  } else if (data.nextSyncUrl) {
    return {
      items,
      nextSyncToken: getToken(data.nextSyncUrl)
    };
  } else {
    return { items: [] };
  }
}
function getToken(url) {
  const urlParts = url.split("?");
  return urlParts.length > 0 ? urlParts[1].replace("sync_token=", "") : "";
}

// node_modules/contentful/dist/esm/utils/normalize-search-parameters.js
function normalizeSearchParameters(query) {
  const convertedQuery = {};
  let hasConverted = false;
  for (const key in query) {
    if (Array.isArray(query[key])) {
      convertedQuery[key] = query[key].join(",");
      hasConverted = true;
    }
  }
  if (hasConverted) {
    return Object.assign(Object.assign({}, query), convertedQuery);
  }
  return query;
}

// node_modules/contentful/dist/esm/utils/query-selection-set.js
function getQuerySelectionSet(query) {
  if (!query.select) {
    return /* @__PURE__ */ new Set();
  }
  const allSelects = Array.isArray(query.select) ? query.select : query.select.split(",").map((q2) => q2.trim());
  return new Set(allSelects);
}

// node_modules/contentful/dist/esm/utils/normalize-select.js
function normalizeSelect(query) {
  if (!query.select) {
    return query;
  }
  const selectedSet = getQuerySelectionSet(query);
  if (selectedSet.has("sys")) {
    return query;
  }
  selectedSet.add("sys.id");
  selectedSet.add("sys.type");
  return Object.assign(Object.assign({}, query), { select: [...selectedSet].join(",") });
}

// node_modules/contentful/dist/esm/utils/resolve-circular.js
function resolveCircular(data, { resolveLinks, removeUnresolved }) {
  const wrappedData = mixinStringifySafe(data);
  if (resolveLinks) {
    wrappedData.items = esm_default(wrappedData, {
      removeUnresolved,
      itemEntryPoints: ["fields"]
    });
  }
  return wrappedData;
}

// node_modules/contentful/dist/esm/utils/validation-error.js
var ValidationError = class extends Error {
  constructor(name, message) {
    super(`Invalid "${name}" provided, ` + message);
    this.name = "ValidationError";
  }
};

// node_modules/contentful/dist/esm/utils/validate-timestamp.js
function validateTimestamp(name, timestamp, options) {
  options = options || {};
  if (typeof timestamp !== "number") {
    throw new ValidationError(name, `only numeric values are allowed for timestamps, provided type was "${typeof timestamp}"`);
  }
  if (options.maximum && timestamp > options.maximum) {
    throw new ValidationError(name, `value (${timestamp}) cannot be further in the future than expected maximum (${options.maximum})`);
  }
  if (options.now && timestamp < options.now) {
    throw new ValidationError(name, `value (${timestamp}) cannot be in the past, current time was ${options.now}`);
  }
}

// node_modules/contentful/dist/esm/utils/validate-params.js
function checkLocaleParamIsAll(query) {
  if (query.locale === "*") {
    throw new ValidationError("locale", `The use of locale='*' is no longer supported.To fetch an entry in all existing locales,
      use client.withAllLocales instead of the locale='*' parameter.`);
  }
}
function checkLocaleParamExists(query) {
  if (query.locale) {
    throw new ValidationError("locale", "The `locale` parameter is not allowed");
  }
}
function validateLocaleParam(query, isWithAllLocalesClient) {
  if (isWithAllLocalesClient) {
    checkLocaleParamExists(query);
  } else {
    checkLocaleParamIsAll(query);
  }
  return;
}
function validateResolveLinksParam(query) {
  if ("resolveLinks" in query) {
    throw new ValidationError("resolveLinks", `The use of the 'resolveLinks' parameter is no longer supported. By default, links are resolved.
      If you do not want to resolve links, use client.withoutLinkResolution.`);
  }
  return;
}
function validateRemoveUnresolvedParam(query) {
  if ("removeUnresolved" in query) {
    throw new ValidationError("removeUnresolved", `The use of the 'removeUnresolved' parameter is no longer supported. By default, unresolved links are kept as link objects.
      If you do not want to include unresolved links, use client.withoutUnresolvableLinks.`);
  }
  return;
}
function checkIncludeContentSourceMapsParamIsAllowed(host, includeContentSourceMaps) {
  if (includeContentSourceMaps === void 0) {
    return false;
  }
  if (typeof includeContentSourceMaps !== "boolean") {
    throw new ValidationError("includeContentSourceMaps", `The 'includeContentSourceMaps' parameter must be a boolean.`);
  }
  const includeContentSourceMapsIsAllowed = host === "preview.contentful.com";
  if (includeContentSourceMaps && !includeContentSourceMapsIsAllowed) {
    throw new ValidationError("includeContentSourceMaps", `The 'includeContentSourceMaps' parameter can only be used with the CPA. Please set host to 'preview.contentful.com' to include Content Source Maps.
      `);
  }
  return includeContentSourceMaps;
}

// node_modules/contentful/dist/esm/utils/validate-search-parameters.js
function validateSearchParameters(query) {
  for (const key in query) {
    const value = query[key];
    if (typeof value === "object" && value !== null && !Array.isArray(value)) {
      throw new Error(`Objects are not supported as value for the "${key}" query parameter.`);
    }
  }
}

// node_modules/contentful/dist/esm/create-contentful-api.js
var ASSET_KEY_MAX_LIFETIME = 48 * 60 * 60;
var NotFoundError = class extends Error {
  constructor(id, environment, space) {
    super("The resource could not be found.");
    this.sys = {
      type: "Error",
      id: "NotFound"
    };
    this.details = {
      type: "Entry",
      id,
      environment,
      space
    };
  }
};
function createContentfulApi({ http, getGlobalOptions }, options) {
  const notFoundError = (id = "unknown") => {
    return new NotFoundError(id, getGlobalOptions().environment, getGlobalOptions().space);
  };
  const getBaseUrl = (context) => {
    let baseUrl = context === "space" ? getGlobalOptions().spaceBaseUrl : getGlobalOptions().environmentBaseUrl;
    if (!baseUrl) {
      throw new Error("Please define baseUrl for " + context);
    }
    if (!baseUrl.endsWith("/")) {
      baseUrl += "/";
    }
    return baseUrl;
  };
  function maybeEnableSourceMaps(query = {}) {
    var _a3, _b;
    const params = http.httpClientParams;
    const includeContentSourceMaps = (_a3 = params === null || params === void 0 ? void 0 : params.includeContentSourceMaps) !== null && _a3 !== void 0 ? _a3 : (_b = params === null || params === void 0 ? void 0 : params.alphaFeatures) === null || _b === void 0 ? void 0 : _b.includeContentSourceMaps;
    const host = params === null || params === void 0 ? void 0 : params.host;
    const areAllowed = checkIncludeContentSourceMapsParamIsAllowed(host, includeContentSourceMaps);
    if (areAllowed) {
      query.includeContentSourceMaps = true;
      if (query.select) {
        const selection = getQuerySelectionSet(query);
        selection.add("sys");
        query.select = Array.from(selection).join(",");
      }
    }
    return query;
  }
  function maybeEncodeCPAResponse(data, config) {
    var _a3;
    const includeContentSourceMaps = (_a3 = config === null || config === void 0 ? void 0 : config.params) === null || _a3 === void 0 ? void 0 : _a3.includeContentSourceMaps;
    if (includeContentSourceMaps) {
      return ue(data);
    }
    return data;
  }
  async function get({ context, path, config }) {
    const baseUrl = getBaseUrl(context);
    try {
      const response = await http.get(baseUrl + path, config);
      return maybeEncodeCPAResponse(response.data, config);
    } catch (error) {
      errorHandler(error);
    }
  }
  async function post({ context, path, data, config }) {
    const baseUrl = getBaseUrl(context);
    try {
      const response = await http.post(baseUrl + path, data, config);
      return response.data;
    } catch (error) {
      errorHandler(error);
    }
  }
  async function getSpace() {
    return get({ context: "space", path: "" });
  }
  async function getContentType(id) {
    return get({
      context: "environment",
      path: `content_types/${id}`
    });
  }
  async function getContentTypes(query = {}) {
    return get({
      context: "environment",
      path: "content_types",
      config: createRequestConfig({ query })
    });
  }
  async function getEntry(id, query = {}) {
    return makeGetEntry(id, query, options);
  }
  async function getEntries(query = {}) {
    return makeGetEntries(query, options);
  }
  async function makeGetEntry(id, query, options2 = {
    withAllLocales: false,
    withoutLinkResolution: false,
    withoutUnresolvableLinks: false
  }) {
    const { withAllLocales } = options2;
    validateLocaleParam(query, withAllLocales);
    validateResolveLinksParam(query);
    validateRemoveUnresolvedParam(query);
    validateSearchParameters(query);
    return internalGetEntry(id, withAllLocales ? Object.assign(Object.assign({}, query), { locale: "*" }) : query, options2);
  }
  async function internalGetEntry(id, query, options2) {
    if (!id) {
      throw notFoundError(id);
    }
    try {
      const response = await internalGetEntries(Object.assign({ "sys.id": id }, maybeEnableSourceMaps(query)), options2);
      if (response.items.length > 0) {
        return response.items[0];
      } else {
        throw notFoundError(id);
      }
    } catch (error) {
      errorHandler(error);
    }
  }
  async function makeGetEntries(query, options2 = {
    withAllLocales: false,
    withoutLinkResolution: false,
    withoutUnresolvableLinks: false
  }) {
    const { withAllLocales } = options2;
    validateLocaleParam(query, withAllLocales);
    validateResolveLinksParam(query);
    validateRemoveUnresolvedParam(query);
    validateSearchParameters(query);
    return internalGetEntries(withAllLocales ? Object.assign(Object.assign({}, query), { locale: "*" }) : query, options2);
  }
  async function internalGetEntries(query, options2) {
    const { withoutLinkResolution, withoutUnresolvableLinks } = options2;
    try {
      const entries = await get({
        context: "environment",
        path: "entries",
        config: createRequestConfig({
          query: maybeEnableSourceMaps(normalizeSearchParameters(normalizeSelect(query)))
        })
      });
      return resolveCircular(entries, {
        resolveLinks: !withoutLinkResolution,
        removeUnresolved: withoutUnresolvableLinks !== null && withoutUnresolvableLinks !== void 0 ? withoutUnresolvableLinks : false
      });
    } catch (error) {
      errorHandler(error);
    }
  }
  async function getAsset(id, query = {}) {
    return makeGetAsset(id, query, options);
  }
  async function getAssets(query = {}) {
    return makeGetAssets(query, options);
  }
  async function makeGetAssets(query, options2 = {
    withAllLocales: false,
    withoutLinkResolution: false,
    withoutUnresolvableLinks: false
  }) {
    const { withAllLocales } = options2;
    validateLocaleParam(query, withAllLocales);
    validateSearchParameters(query);
    const localeSpecificQuery = withAllLocales ? Object.assign(Object.assign({}, query), { locale: "*" }) : query;
    return internalGetAssets(localeSpecificQuery);
  }
  async function internalGetAsset(id, query) {
    try {
      return get({
        context: "environment",
        path: `assets/${id}`,
        config: createRequestConfig({ query: maybeEnableSourceMaps(normalizeSelect(query)) })
      });
    } catch (error) {
      errorHandler(error);
    }
  }
  async function makeGetAsset(id, query, options2 = {
    withAllLocales: false,
    withoutLinkResolution: false,
    withoutUnresolvableLinks: false
  }) {
    const { withAllLocales } = options2;
    validateLocaleParam(query, withAllLocales);
    validateSearchParameters(query);
    const localeSpecificQuery = withAllLocales ? Object.assign(Object.assign({}, query), { locale: "*" }) : query;
    return internalGetAsset(id, localeSpecificQuery);
  }
  async function internalGetAssets(query) {
    try {
      return get({
        context: "environment",
        path: "assets",
        config: createRequestConfig({
          query: maybeEnableSourceMaps(normalizeSearchParameters(normalizeSelect(query)))
        })
      });
    } catch (error) {
      errorHandler(error);
    }
  }
  async function getTag2(id) {
    return get({
      context: "environment",
      path: `tags/${id}`
    });
  }
  async function getTags(query = {}) {
    validateSearchParameters(query);
    return get({
      context: "environment",
      path: "tags",
      config: createRequestConfig({ query: normalizeSearchParameters(normalizeSelect(query)) })
    });
  }
  async function createAssetKey(expiresAt) {
    try {
      const now = Math.floor(Date.now() / 1e3);
      const currentMaxLifetime = now + ASSET_KEY_MAX_LIFETIME;
      validateTimestamp("expiresAt", expiresAt, { maximum: currentMaxLifetime, now });
    } catch (error) {
      errorHandler(error);
    }
    return post({
      context: "environment",
      path: "asset_keys",
      data: { expiresAt }
    });
  }
  async function getLocales(query = {}) {
    validateSearchParameters(query);
    return get({
      context: "environment",
      path: "locales",
      config: createRequestConfig({ query: normalizeSelect(query) })
    });
  }
  async function sync(query, syncOptions = { paginate: true }) {
    return makePagedSync(query, syncOptions, options);
  }
  async function makePagedSync(query, syncOptions, options2 = {
    withAllLocales: false,
    withoutLinkResolution: false,
    withoutUnresolvableLinks: false
  }) {
    validateResolveLinksParam(query);
    validateRemoveUnresolvedParam(query);
    const combinedOptions = Object.assign(Object.assign({}, syncOptions), options2);
    switchToEnvironment(http);
    return pagedSync(http, query, combinedOptions);
  }
  function parseEntries(data) {
    return makeParseEntries(data, options);
  }
  function makeParseEntries(data, options2 = {
    withAllLocales: false,
    withoutLinkResolution: false,
    withoutUnresolvableLinks: false
  }) {
    return internalParseEntries(data, options2);
  }
  function internalParseEntries(data, options2) {
    const { withoutLinkResolution, withoutUnresolvableLinks } = options2;
    return resolveCircular(data, {
      resolveLinks: !withoutLinkResolution,
      removeUnresolved: withoutUnresolvableLinks !== null && withoutUnresolvableLinks !== void 0 ? withoutUnresolvableLinks : false
    });
  }
  function getConceptScheme(id, query = {}) {
    return internalGetConceptScheme(id, query);
  }
  async function internalGetConceptScheme(id, query = {}) {
    try {
      return get({
        context: "environment",
        path: `taxonomy/concept-schemes/${id}`,
        config: createRequestConfig({
          query: normalizeSearchParameters(normalizeSelect(query))
        })
      });
    } catch (error) {
      errorHandler(error);
    }
  }
  function getConceptSchemes(query = {}) {
    return internalGetConceptSchemes(query);
  }
  async function internalGetConceptSchemes(query = {}) {
    try {
      return get({
        context: "environment",
        path: "taxonomy/concept-schemes",
        config: createRequestConfig({
          query: normalizeSearchParameters(normalizeSelect(query))
        })
      });
    } catch (error) {
      errorHandler(error);
    }
  }
  function getConcept(id, query = {}) {
    return internalGetConcept(id, query);
  }
  async function internalGetConcept(id, query = {}) {
    try {
      return get({
        context: "environment",
        path: `taxonomy/concepts/${id}`,
        config: createRequestConfig({
          query: normalizeSearchParameters(normalizeSelect(query))
        })
      });
    } catch (error) {
      errorHandler(error);
    }
  }
  function getConcepts(query = {}) {
    return internalGetConcepts(query);
  }
  async function internalGetConcepts(query = {}) {
    try {
      return get({
        context: "environment",
        path: "taxonomy/concepts",
        config: createRequestConfig({
          query: normalizeSearchParameters(normalizeSelect(query))
        })
      });
    } catch (error) {
      errorHandler(error);
    }
  }
  function switchToEnvironment(http2) {
    http2.defaults.baseURL = getGlobalOptions().environmentBaseUrl;
  }
  return {
    version: "11.3.0",
    getSpace,
    getContentType,
    getContentTypes,
    getAsset,
    getAssets,
    getTag: getTag2,
    getTags,
    getLocales,
    parseEntries,
    sync,
    getEntry,
    getEntries,
    getConceptScheme,
    getConceptSchemes,
    getConcept,
    getConcepts,
    createAssetKey
  };
}

// node_modules/contentful/dist/esm/make-client.js
function create3({ http, getGlobalOptions }, options, makeInnerClient) {
  const client = createContentfulApi({
    http,
    getGlobalOptions
  }, options);
  const response = client ? client : {};
  Object.defineProperty(response, "withAllLocales", {
    get: () => makeInnerClient(Object.assign(Object.assign({}, options), { withAllLocales: true }))
  });
  Object.defineProperty(response, "withoutLinkResolution", {
    get: () => makeInnerClient(Object.assign(Object.assign({}, options), { withoutLinkResolution: true }))
  });
  Object.defineProperty(response, "withoutUnresolvableLinks", {
    get: () => makeInnerClient(Object.assign(Object.assign({}, options), { withoutUnresolvableLinks: true }))
  });
  return Object.create(response);
}
var makeClient = ({ http, getGlobalOptions }) => {
  function makeInnerClient(options) {
    return create3({ http, getGlobalOptions }, options, makeInnerClient);
  }
  const client = createContentfulApi({ http, getGlobalOptions }, {
    withoutLinkResolution: false,
    withAllLocales: false,
    withoutUnresolvableLinks: false
  });
  return Object.assign(Object.assign({}, client), {
    get withAllLocales() {
      return makeInnerClient({
        withAllLocales: true,
        withoutLinkResolution: false,
        withoutUnresolvableLinks: false
      });
    },
    get withoutLinkResolution() {
      return makeInnerClient({
        withAllLocales: false,
        withoutLinkResolution: true,
        withoutUnresolvableLinks: false
      });
    },
    get withoutUnresolvableLinks() {
      return makeInnerClient({
        withAllLocales: false,
        withoutLinkResolution: false,
        withoutUnresolvableLinks: true
      });
    }
  });
};

// node_modules/contentful/dist/esm/contentful.js
function createClient(params) {
  if (!params.accessToken) {
    throw new TypeError("Expected parameter accessToken");
  }
  if (!params.space) {
    throw new TypeError("Expected parameter space");
  }
  validateResolveLinksParam(params);
  validateRemoveUnresolvedParam(params);
  const defaultConfig = {
    resolveLinks: true,
    removeUnresolved: false,
    defaultHostname: "cdn.contentful.com",
    environment: "master"
  };
  const config = Object.assign(Object.assign({}, defaultConfig), params);
  const userAgentHeader = getUserAgentHeader(`contentful.js/${"11.3.0"}`, config.application, config.integration);
  config.headers = Object.assign(Object.assign({}, config.headers), { "Content-Type": "application/vnd.contentful.delivery.v1+json", "X-Contentful-User-Agent": userAgentHeader });
  const http = createHttpClient(axios_default, config);
  if (!http.defaults.baseURL) {
    throw new Error("Please define a baseURL");
  }
  const getGlobalOptions = createGlobalOptions({
    space: config.space,
    environment: config.environment,
    spaceBaseUrl: http.defaults.baseURL,
    environmentBaseUrl: `${http.defaults.baseURL}environments/${config.environment}`
  });
  http.defaults.baseURL = getGlobalOptions({}).environmentBaseUrl;
  return makeClient({
    http,
    getGlobalOptions
  });
}

// node_modules/contentful/dist/esm/index.js
var import_json_stringify_safe2 = __toESM(require_stringify2());
export {
  createClient,
  createGlobalOptions
};
//# sourceMappingURL=contentful.js.map
